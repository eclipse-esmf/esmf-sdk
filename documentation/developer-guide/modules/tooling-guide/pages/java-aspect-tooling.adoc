:page-partial:

[[aspect-model-java-tooling]]
= Java Tooling for Working with Aspect Models

[[general-considerations]]
== General Considerations

In this section, the Java APIs for working with Aspect Models are described. All of the components described in the
following subsections can either be included in your project using a dedicated dependency (as described in the
respective subsection), _or_ you can use the `aspect-model-starter` artifact that aggregates all necessary dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-starter-artifact.adoc[]

[[versioning]]
== Getting the right version

The tooling can be made available in two different versions: `release` and `milestone`. The release version represents a stable version of the product
and can be referenced in your projects in the usual way from the Maven Central repository. There is also the possibility to have the intermediate builds
made available, these are called `milestone` builds. Instead of Maven Central, these are released via
https://github.com/orgs/eclipse-esmf/packages?repo_name=esmf-sdk[GitHub Packages] mechanism. +
To be able to use the artifacts released in this way in your projects, first the right repository has to be added to your `pom.xml` file:
[source, xml]
----
<repositories>
  <repository>
    <id>github</id>
    <name>ESMF SDK</name>
    <url>https://maven.pkg.github.com/eclipse-esmf/esmf-sdk</url>
    <releases><enabled>true</enabled></releases>
    <snapshots><enabled>true</enabled></snapshots>
  </repository>
</repositories>
----
Then the desired dependencies can be referenced in the usual way. For an example, please refer to
https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-apache-maven-registry#installing-a-package[Github - Installing a package].

[[jdk-requirements]]
== JDK requirements

The esmf-sdk components are built with Java 17 and require a JDK >= 17 such as
https://adoptium.net/[Adoptium Temurin].

The esmf-sdk can also be used with a Java 17-compatible https://www.graalvm.org/[GraalVM JDK]. With
GraalVM you need to make the Graal JavaScript component available, as parts of the SDK such as the
Aspect Model validation component require embedded JavaScript execution:

* For using the esmf-sdk in the GraalVM itself, install the JS component using the
  https://www.graalvm.org/22.3/reference-manual/js/[GraalVM Updater]: `gu install js`
* For using the esmf-sdk with GraalVM `native-image`, be sure to use the `--language:js` option when
  building the native image; for more information see
  https://www.graalvm.org/22.3/reference-manual/polyglot-programming/[polyglot programming].

[[parsing-aspect-model-urns]]
== Parsing Aspect Model URNs

The `aspect-model-urn` artifact provides a way to parse and validate Aspect model element URNs as described in the
xref:samm-specification:ROOT:namespaces.adoc[specification].

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$ParseAspectModelUrn.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$ParseAspectModelUrn.java[tags=parseAspectModelUrn]
----

To include the artifact, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-urn-artifact.adoc[]

[[loading-and-saving]]
== Loading and Saving Aspect Models

Aspect models are, like the Semantic Aspect Meta Model, described using the Resource Description Format (RDF,
xref:samm-specification:appendix:bibliography.adoc#rdf11[[rdf11\]]) and the Terse RDF Triple Language syntax
(TTL, xref:samm-specification:appendix:bibliography.adoc#turtle[[turtle\]]). When an Aspect Model is loaded,
there are two ways of working with it: Either on the abstraction level of the underlying RDF/Turtle
serialization, or on the native Java Aspect Model level, where the model is represented as a Java object
graph. Both approaches have different use cases and advantages and both are supported by the Aspect Model Java
tooling:

[width="100%", options="header", cols="50,50"]
|===
| Working on the RDF level | Using the Java Aspect model
a|
* Low level, focus on power and flexibility
* Flexibly navigate and filter the model on the RDF statements level
* Work with models that are valid RDF, but incomplete Aspect Models, e.g. in Aspect model editors
* Use SPARQL xref:samm-specification:appendix:bibliography.adoc#sparql[[sparql\]] to execute complex queries on Aspect Models
a|
* High level, focus on convenience and type-safety
* Use Aspect Model-specific interfaces for type-safe code
* Use Java native data types (e.g. `java.math.BigInteger` for `xsd:integer`)
* Easily traverse the model on the abstraction level of Aspect Model elements
|===

As a rule of thumb, if your use case mostly consists of _consuming_ Aspect models, you should prefer the Java
Aspect model, if you _create_ or _edit_ Aspect models, or build code interfacing with other RDF vocabularies,
this is better done using the RDF API.

[[loading-an-aspect-model-java-model-level]]
=== Loading an Aspect Model to work on the Java Aspect Model Level

To load an AspectModel, you use the `org.eclipse.esmf.aspectmodel.loader.AspectModelLoader` class. An instance
of `AspectModelLoader` provides `load()` methods to load an Aspect Model from an InputStream, one or multiple
Files, or a number of `AspectModelUrn` (where you can delegate finding out _where_ a model element is defined
to the AspectModelLoader - details on that are explained in the next section).

The `AspectModelLoader` loads Aspect Models based on the most recent version of the Semantic Aspect Meta Model
and previous versions: Models based on older meta model versions are automatically translated to models
corresponding to the latest meta model version.

The resulting `AspectModel` object contains information about the loaded model elements, their
namespaces and the files they were defined in. Details about the structure of these objects can be
found in the
https://github.com/eclipse-esmf/esmf-semantic-aspect-meta-model/blob/main/documentation/decisions/0007-model-resolution.md[Decision
Record 0007]. The `AspectModel` provides the methods `elements()`, `files()` and `namespaces()` as
well as the convenience methods `aspects()` (which returns all Aspect elements in the model) and
`aspect()`, which returns the single Aspect element if one exists.

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelObjects.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelObjects.java[tags=loadModel]
----

To include the Java Aspect Model artifact, use the following dependency:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-meta-model-java-artifact.adoc[]

[[understanding-model-resolution]]
=== Understanding Model Resolution

The example in the last section showed how a self-contained Aspect Model file can be loaded (i.e., a
file that does not refer to model element definitions in other files or namespaces). Whenever models
are loaded that could contain such references, or you want to load a model element by URN, the
AspectModelLoader relies on so-called _resolution strategies_. A resolution strategy is a function
that takes a model element identifier (a model element URN) as an input and returns the content of
the file that contains the corresponding model element definition. Note that this is not necessarily
a file in the local filesystem, but it could also be a remote file or even exist only virtually as a
collection of statements in an RDF triple store. Several `ResolutionStrategy`&#8203;s are provided
that can be instantiated and passed to the `AspectModelLoader` constructor to enable it to find
model element definitions:

* The `FileSystemStrategy` resolves elements from files in the file system which are either structured in the
  xref:tooling-guide:samm-cli.adoc#models-directory-structure[models directory structure] or exist as flat
  list of files in one directory (by using `FileSystemStrategy` with a `FlatModelsRoot`).
* The `ClassPathStrategy` resolves model elements from resources in the Java class path.
* The `FromLoadedFileStrategy` resolves model elements from an `AspectModelFile` that already resides in
  memory.
* The `EitherStrategy` can be used to chain two or more different `ResolutionStrategy`&#8203;s.
* The `ExternalResolverStrategy` delegates resolution to an external command such as a script; it is used in
  the implementation of the `--custom-resolver` option of the xref:tooling-guide:samm-cli.adoc[samm-cli].

In addition, custom resolution strategies can be provided by implementing the `ResolutionStrategy` interface.

The following example demonstrates how to pass a custom instance of a `ResolutionStrategy` and resolve a model
element by URN:

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=loadAndResolveFromUrn]
----

[[loading-an-aspect-model-rdf-level]]
=== Loading an Aspect Model to work on the RDF Level

The following example shows how to use the `AspectModelResolver` to load an Aspect Model.

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=loadAndResolveFromFile]
----

After loading an `AspectModel` using the `AspectModelLoader`, you can access the `mergedModel()` on the
`AspectModel`, which represents the merged RDF graph of all source files that were loaded in the model and
therefore contains all transitively referenced model element definitions. Alternatively, you can also access
the `sourceModel()` of each Aspect Model file given by `files()`, which will return only the RDF graph of this
file.

[[serializing-an-aspect-model]]
=== Serializing a Java Aspect Model into a RDF/Turtle Aspect Model

The serialize an Aspect into its corresponding RDF/Turtle representation, you can use the `AspectSerializer`,
as demonstrated in the example below:

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$SerializeAspectModel.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$SerializeAspectModel.java[tags=serialize]
----

To include the serializer artifact, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-serializer-artifact.adoc[]

[[validating-aspect-models]]
== Validating Aspect Models

Aspect Models are validated using the `AspectModelValidator`. Validation returns a list of
`Violation`&#8203;s. A violation has a human-readable message and a unique error code and provides access
to the `EvaluationContext` which contains references to the model element that caused the
violation and the SHACL shape that triggered the violation.

Each possible type of violation is a subtype of the `Violation` interface and provides additional
context information specific to this type, for example, the `MinLengthViolation` provides `int min`
(the allowed length) and `int actual` (the length that was encountered in the model).

Consider the following example:

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$ValidateAspectModel.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$ValidateAspectModel.java[tags=validate]
----

<1> To format the validation result into an human-readable form, use the `ViolationFormatter` or the
`DetailedViolationFormatter`. Note that those are only intended for text-based interfaces such as
CLIs.
<2> Every application dealing with validation results that needs to transform the results into some
different structure can implement the `Violation.Visitor` Interface with a suitable target
type `(String` used as an example here) and use the visitor to handle the different types of
Violations in a type-safe way.

The `AspectModelValidator` also provides the `loadModel(Supplier<AspectModel>)` method that can be used in
conjunction with `() -> new AspectModeLoader().load(...)` to have exceptions that might be created during the
Aspect Model loading process, for example due to model resolution failures or syntax errors in the input
files, be turned into a `List<Violation>` that can be passed to the aforementioned violation formatters. This
allows for custom structured handling of problems that occur during model loading.

To include the model validator, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-validator-artifact.adoc[]

[[generating-documentation]]
== Generating Documentation for Aspect Models

Different types of artifacts can be generated from an Aspect model. All corresponding generators are included in the
following dependency:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-document-generators-artifact.adoc[]

The documentation generation APIs provide methods that take as an argument a `Function<String, java.io.OutputStream>`.
This is a mapping function that takes a file name as an input (which is determined by the respective generator) and
returns a corresponding `OutputStream`, for example (but not necessarily) a `FileOutputStream`. By providing this
function when calling the generator method, you can control where the output is written to, even when the generator
creates multiple files. For the code examples in the following subsections, we assume that the following method is
defined for calling the generators:

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$AbstractGenerator.java[tags=outputStream]
----

[[generating-diagrams]]
=== Generating SVG or PNG Diagrams

Using the `AspectModelDiagramGenerator`, automatically layouted diagrams can be created for Aspect models in
the formats PNG and SVG.

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateDiagrams.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateDiagrams.java[tags=generate]
----

<1> The diagram generator is initialized with the loaded model.
<2> The simple call for one output format and one language (i.e., descriptions and preferredNames of one locale) takes
one output stream to write the image to.
<3> It is also possible to generate multiple diagrams, one for each combination of output format and language. For that,
the set of target formats is given as well as a mapping function.

[[generating-html-documentation]]
=== Generating HTML Documentation

A HTML reference documentation for an Aspect model can be generated as shown in the following code sample. The
documentation contains an overview diagram and describes the model elements as specified in the Aspect model. Preferred
names and descriptions in the respective language from the Aspect model are shown in the resulting document as part of
each model element.

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateHtml.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateHtml.java[tags=generate]
----

<1> The HTML generator is initialized with the context consisting of the loaded RDF model and the
selected Aspect.
<2> HTML generation can be controlled via a map of options; using an empty map implies default values.

[[generating-sample-json-payload]]
=== Generating Sample JSON Payload

The sample JSON payload generator is used to create a valid JSON payload for an Aspect model as it could be returned by
an Aspect that implements that Aspect model. This follows the
xref:samm-specification:ROOT:payloads.adoc#mapping-to-json[mapping rules] as defined in the Meta Model specification.
The generator uses `samm:exampleValue`&#8203;s of Properties if present, otherwise random values corresponding to the
respective data types are generated.

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJsonPayload.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJsonPayload.java[tags=generate]
----

=== Generating JSON Schema

The JSON schema generator creates a https://json-schema.org/[JSON Schema] that describes the payload for an Aspect model
as it could be returned by an Aspect that implements that Aspect model.

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJsonSchema.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJsonSchema.java[tags=generate]
----

=== Generating OpenAPI Specification

The OpenAPI specification generator creates either a https://json-schema.org/[JSON Schema] or a https://yaml.org/[Yaml Spec]
that specifies an Aspect regarding to the https://github.com/OAI/OpenAPI-Specification/[OpenApi specification].
The currently used versions corresponds https://json-schema.org/specification-links.html#draft-4[Draft 4] of the JSON Schema specification,
and https://github.com/OAI/OpenAPI-Specification/blob/3.0.1/versions/3.0.1.md[3.0.1].

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateOpenApi.java[tags=imports]
----
++++
</details>
++++

.Generate OpenAPI YAML
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateOpenApi.java[tags=generateYaml]
----

.Generate OpenAPI JSON
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateOpenApi.java[tags=generateJson]
----

NOTE: For Enumerations with complex data types, the values are modelled as instances of the Entity defined as the
Enumeration's data type (see xref:samm-specification:ROOT:modeling-guidelines.adoc#declaring-enumerations[Declaring
Enumerations] for more information). In case the Entity instances contain Properties with a sorted collection as their
data type, the order of the values of said collection in the Entity instances is not preserved in the generated OpenAPI
specification. Preserving this order in OpenAPI is not possible at this point.

=== Generating AsyncAPI Specification

The AsyncAPI specification generator creates either a https://json-schema.org/[JSON Schema] or a https://yaml.org/[Yaml Spec]
that specifies an Aspect regarding to the https://www.asyncapi.com/en[AsyncApi specification].
The currently used versions correspond to https://json-schema.org/specification-links.html#draft-4[Draft 4] of the JSON Schema specification,
and https://github.com/asyncapi/spec/blob/master/spec/asyncapi.md[3.0.0] of the AsyncAPI specification.

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateAsyncApi.java[tags=imports]
----
++++
</details>
++++

.Generate AsyncAPI YAML
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateAsyncApi.java[tags=generateYaml]
----

.Generate AsyncAPI JSON
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateAsyncApi.java[tags=generateJson]
----

[[generating-sql]]
=== Generating SQL for Aspect Models

Using the Aspect Model SQL generator, an SQL script can be generated that sets up a table for data
corresponding to the Aspect. The current implementation provides support for the
https://docs.databricks.com/en/sql/language-manual/index.html[Databricks SQL] dialect and a mapping
strategy that uses a denormalized table, i.e., the table contains one column for each Property used
in the Aspect Model (or any of its transitively referenced Entities).

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateSql.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateSql.java[tags=generate]
----

[[databricks-type-mapping]]
==== Databricks Type Mapping

xref:samm-specification:ROOT:datatypes.adoc#data-types[Data types] in the Aspect Model are mapped to Databricks types using the following correspondences:

[width="100%", options="header", cols="33,33,33"]
|===
| Aspect model type | Databricks SQL type | Note
| `xsd:string`  | `STRING` |
| `xsd:boolean` | `BOOLEAN` |
| `xsd:decimal` | `DECIMAL` | While xsd:decimal is by definition unbounded, DECIMAL's default
  precision is 10 digits and can be up to 38. if we assume values larger than that can appear
in the data, the Aspect Models using xsd:decimal should also use a xref:samm-specification:ROOT:characteristics.adoc#fixed-point-constraint[samm-c:FixedPointConstraint] accordingly.
| `xsd:integer` | `DECIMAL` | As opposed to xsd:int, xsd:integer has arbitrary precision, i.e. DECIMAL is needed.
| `xsd:double` | `DOUBLE` |
| `xsd:float` | `FLOAT` |
| `xsd:date` | `STRING` | `DATE` can not be used, because it does not retain timezone information.
| `xsd:time` | `STRING` |
| `xsd:dateTime` | `STRING` |
| `xsd:dateTimeStamp` | `TIMESTAMP` |
| `xsd:gYear` | `STRING` |
| `xsd:gMonth` | `STRING` |
| `xsd:gDay` | `STRING` |
| `xsd:gYearMonth` | `STRING` |
| `xsd:gMonthDay` | `STRING` |
| `xsd:duration` | `STRING` |
| `xsd:yearMonthDuration` | `STRING` |
| `xsd:dayTimeDuration` | `STRING` |
| `xsd:byte` | `TINYINT` |
| `xsd:short` | `SMALLINT` |
| `xsd:int` | `INT` |
| `xsd:long` | `BIGINT` |
| `xsd:unsignedByte` | `SMALLINT` |
| `xsd:unsignedShort` | `INT` |
| `xsd:unsignedInt` | `BIGINT` |
| `xsd:unsignedLong` | `DECIMAL` |
| `xsd:positiveInteger` | `DECIMAL` |
| `xsd:nonNegativeInteger` | `DECIMAL` |
| `xsd:negativeInteger` | `DECIMAL` |
| `xsd:nonPositiveInteger` | `DECIMAL` |
| `xsd:hexBinary` | `BINARY` |
| `xsd:base64Binary` | `BINARY` |
| `xsd:anyURI` | `STRING` |
| `samm:curie` | `STRING` |
|===

[[generating-java-code]]
== Generating Java Code for Aspect Models

Java code can be generated from an Aspect model in two ways:

. The generated code represents the Aspect payload. Aspects and Entities become Java classes; their Properties become
fields in the classes. Characteristics are not first-class elements, but are implicitly represented by the usage of
corresponding data types (e.g. using `java.util.Set` as the type for the `Set` Characteristic of a Property) or
`javax.validation` annotations. The generated classes can be used in a straightforward fashion, but they do not contain
information about the underlying Aspect model such as its version number. Parts of the Aspect model that have no
representation in its corresponding JSON payload are not part of those classes either, in particular descriptions and
preferred names. These classes are called POJOs (Plain Old Java Objects), as they do not contain logic but serve mainly as data containers.

. The generated code represents the Aspect model itself: It is a type-safe variant of the model and includes every
information that is also present in the model such as Characteristics, descriptions including language tags and original
XSD data types. It is however not intended to store payload corresponding to an Aspect. Theses classes are called static
meta classes, because they are created at compile time (_static_) and talk about the structure of the information, not
the information itself (_meta_).

Depending on the use case, you would either use one or both of the types simultaneously.

To include the Java generator, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-java-generator-artifact.adoc[]

[[type-mapping]]
=== Type Mapping

In the Java code generated from an Aspect model, the scalar Aspect model
xref:samm-specification:ROOT:datatypes.adoc#data-types[data types] are mapped to native Java types. The following table
lists the correspondences.

[width="100%", options="header", cols="50,50"]
|===
| Aspect model type | Java native type
| `xsd:string`  | `java.lang.String`
| `xsd:boolean` | `java.lang.Boolean`
| `xsd:decimal` | `java.math.BigDecimal`
| `xsd:integer` | `java.math.BigDecimal`
| `xsd:double` | `java.lang.Double`
| `xsd:float` | `java.lang.Float`
| `xsd:date` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:time` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:dateTime` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:dateTimeStamp` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:gYear` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:gMonth` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:gDay` | `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:gYearMonth` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:gMonthDay` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:duration` | `javax.xml.datatype.Duration`
| `xsd:yearMonthDuration` | `javax.xml.datatype.Duration`
| `xsd:dayTimeDuration` | `javax.xml.datatype.Duration`
| `xsd:byte` | `java.lang.Byte`
| `xsd:short` | `java.lang.Short`
| `xsd:int` | `java.lang.Integer`
| `xsd:long` | `java.lang.Long`
| `xsd:unsignedByte` | `java.lang.Short`
| `xsd:unsignedShort` | `java.lang.Integer`
| `xsd:unsignedInt` | `java.lang.Long`
| `xsd:unsignedLong` | `java.math.BigInteger`
| `xsd:positiveInteger` | `java.math.BigInteger`
| `xsd:nonNegativeInteger` | `java.math.BigInteger`
| `xsd:negativeInteger` | `java.math.BigInteger`
| `xsd:nonPositiveInteger` | `java.math.BigInteger`
| `xsd:hexBinary` | `byte[]`
| `xsd:base64Binary` | `byte[]`
| `xsd:anyURI` | `java.net.URI`
| `samm:curie` | `org.eclipse.esmf.metamodel.datatypes.Curie`
|===

[[generating-pojos]]
=== Generating POJOs

POJO generation is straightforward; there are two minor differences to the generation of documentation artifacts.
Firstly, when instantiating the generator, you pass a flag indicating whether
https://en.wikipedia.org/wiki/Jackson_(API)[Jackson] annotations should be generated in the class. Secondly, the name
mapping function passed to the generation method takes a `QualifiedName` instead of a String, so that you can decide how
to handle the package structure of the class.

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJavaPojo.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJavaPojo.java[tags=generate]
----

[[generating-static-meta-classes]]
=== Generating Static Meta Classes

For the generation of static meta classes, consider the following example:

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJavaStaticClass.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJavaStaticClass.java[tags=generate]
----

To use the generated static meta classes, you need the following additional dependency:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-static-meta-model-java-artifact.adoc[]

[[providing-custom-macros-for-code-generation]]
==== Providing Custom Macros for Code Generation

It is possible to change predefined sections of the generated classes by providing custom https://velocity.apache.org/[Velocity] templates; see the https://velocity.apache.org/engine/2.3/user-guide.html[Velocity User Guide] for more information.
The custom macros must be defined in a single template file.
The path to the template file as well as its name may be passed as arguments to the code generation, e.g. using the xref:samm-cli.adoc#samm-cli[SAMM-CLI].

Custom macros may be provided for the following sections:

[width="100%",options="header"]
|===
| Section | Macro Name | Default Macro Provided
| Copyright Licence Header | fileHeader | {nok}
|===

NOTE: When using custom macros, macros for all sections above must be provided.

Example:

[source,indent=0]
----
include::example$sample-file-header.vm[]
----

[[modifying-and-creating-aspect-models]]
== Modifying and creating Aspect Models

You can use the `AspectChangeManager` to modify an Aspect Model. Each modifying operation performed
on an Aspect Model is called a _change_. Instances of classes that implement the `Change` interface
can be passed to the `AspectChangeManager` `applyChange()` method. Available `Change`&#8203;s
include renaming Aspect Model files or Model elements, adding and removing Aspect Model files and
moving Aspect Model elements to other or new files in the same or another namespace.

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$EditAspectModel.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$EditAspectModel.java[tags=editModel]
----

[[accessing-samm-programmatically]]
== Accessing the SAMM programmatically

In order to access the source RDF files that describe the SAMM vocabulary, shared Characteristics and Entities
as well as Units, you can add a dependency to the `esmf-aspect-meta-model` artifact. Note that this artifact
does not provide Java classes that represent the meta model.

include::esmf-developer-guide:ROOT:partial$aspect-meta-model-artifact.adoc[]

In order to access the files via `java.lang.Class#getResourceAsStream`, you can refer to the following directory
structure that is present in the artifact:

[source,subs="attributes+,+quotes"]
----
.
├── characteristic
│   └── {aspect-meta-model-version}
│       ├── characteristic-definitions.ttl
│       ├── characteristic-instances.ttl
│       ├── characteristic-shapes.ttl
│       └── characteristic-validations.js
├── entity
│   └── {aspect-meta-model-version}
│       ├── FileResource.ttl
│       ├── ThreeDimensionalPosition.ttl
│       └── TimeSeriesEntity.ttl
├── meta-model
│   └── {aspect-meta-model-version}
│       ├── aspect-meta-model-definitions.ttl
│       ├── aspect-meta-model-shapes.ttl
│       ├── prefix-declarations.ttl
│       └── type-conversions.ttl
└── unit
    └── {aspect-meta-model-version}
        └── units.ttl
----

TIP: You can use the `MetaModelFile` enumeration provided by the `esmf-aspect-meta-model-java` module to
access object representations of the meta model files, for example:

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadMetaModelRdf.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadMetaModelRdf.java[tags=loadMetaModelRdf]
----

[[mapping-aas]]
== Mapping Aspect Models to Asset Administration Shell (AAS) Submodel Templates

The Asset Administration Shell (AAS) and its
https://www.plattform-i40.de/IP/Redaktion/EN/Standardartikel/specification-administrationshell.html[information
model] is a widely recognized standard developed by the https://industrialdigitaltwin.org[Industrial
Digital Twin Association (IDTA)] to express and handle Digital Twins. Central element of the AAS is
the concept of Submodels, which describe certain aspects of a Digital Twin.

The SAMM Aspect Meta Model allows to specify aspects of a digital twin and its semantics. The AAS
Generator module provides mapping implementations to derive AAS Submodels from SAMM Aspect Models.
On the one hand, this allows to integrate SAMM models in AAS environments and on the other hand it
allows AAS submodels to be described with rich semantics, as it is possible with SAMM.

[[details-mapping-aas]]
=== Details of the Mapping Concept

In the following section, the mapping rules applied by the generator are explained. The rules apply
to https://eclipse-esmf.github.io/samm-specification/2.0.0/index.html[SAMM v2.0.0] and
https://www.plattform-i40.de/IP/Redaktion/EN/Downloads/Publikation/Details_of_the_Asset_Administration_Shell_Part1_V3.html[AAS
Specification Part 1 V3.0RC01].

[cols="1,1,2"]
|===
| SAMM  | AAS  | Comment

| **samm:Aspect**  |  aas:Submodel with kind=Template  | Empty Asset and AssetAdministrationShell entries are added to the output file

| samm:name   | aas:Submodel.idShort  |

| samm:preferredName   | aas:Submodel.displayName  |

| samm:description   | aas:Submodel.description  |

| samm:property   | see **samm:Property**  |

| samm:operation   | see **samm:Operation**   |

| samm:Aspect.urn  | aas:Submodel.semanticId  |

| **samm:Property**  | aas:Property, aas:SubmodelElementCollection   | The AAS type is derived from the type of the SAMM Characteristic specifying the SAMM property. Depending on the type it is decided what the resulting AAS element will be. In case of an Entity it will result in a SubmodelElementCollection. It will also be a SubmodelElementCollection if the SAMM Characteristic is of a Collection type (see the https://eclipse-esmf.github.io/samm-specification/2.0.0/characteristics.html[Characteristics taxonomy]). In all other cases an aas:Property will be generated

| samm:Property.name  | aas:Property.idShort |

| samm:Property.urn  | aas:ConceptDescription.identification.id, aas:Property.semanticId|

| samm:Property.preferredName   | aas:Property.displayName  |

| samm:Property.description   | aas:Property.description  |  Note: Also mapped to aas:DataSpecificationIEC61360.definition of the aas:ConceptDescription of this property

| samm:Property.exampleValue  |aas:Property.value  |

| samm:Characteristic.dataType  | aas:Property.valueType |

| **samm:Operation** |  Operation  | in/out parameters are not used in SAMM so the mapping only generates input variables and output variables in AAS

| xref:samm-specification:ROOT:characteristics.adoc#characteristic-characteristic[**samm-c:Characteristic**]  | aas:SubmodelElement, aas:ConceptDescription  | Characteristics in SAMM define the semantics of a property, which includes there types as well as links to further definitions (standards, dictionaries, etc), a natural language description and name in different languages. Type and description are separated in AAS, which is why there is not a one-to-one mapping of a Characteristic to one element in AAS but rather Characteristics are used in the mapping of Properties, first, to guide the generation process and, second, to capture semantics in ConceptDescriptions of properties with data specification "DataSpecificationIEC61360" of the AAS.

| xref:samm-specification:ROOT:characteristics.adoc#collection-characteristic[**samm-c:Collection**] | aas:SubmodelElementList, aas:ConceptDescription  | The general remarks to Characteristics apply also to Collection type Characteristics. However, properties referencing Collections are mapped to SubmodelElementLists. Specific properties of collections are mapped. samm:Set is unique, samm:SortedSet is unique and sorted, samm:List is sorted.

| xref:samm-specification:ROOT:characteristics.adoc#quantifiable-characteristic[**samm-c:Quantifiable**]  | aas:SubmodelElement, aas:ConceptDescription | The general remarks to Characteristics apply also to Quantifiable type Characteristics. Quantifiables (also Duration and Measurement) reference a unit, which is added to the ConceptDescription corresponding the mapped Characteristic.

| xref:samm-specification:ROOT:characteristics.adoc#either-characteristic[**samm-c:Either**]  | aas:SubmodelElement, aas:ConceptDescription | The general remarks to Characteristics apply also to Either. However, the Either characteristic has two distinct entries of which one is to be selected. This concept is not present in AAS. Thus, both entries will be written to a Submodel template, where one has to be ignored.

| xref:samm-specification:ROOT:characteristics.adoc#trait-characteristic[**samm-c:Trait**]  | aas:SubmodelElement, aas:ConceptDescription | The general remarks to Characteristics apply also to Trait. However, the constraint of a trait will be ignored and only the base type will be evaluated, which will act as the characteristic of a property.

| xref:samm-specification:ROOT:characteristics.adoc#code-characteristic[**samm-c:Code**] | aas:SubmodelElement, aas:ConceptDescription | Similar to plain Characteristic.

| xref:samm-specification:ROOT:characteristics.adoc#structured-value-characteristic[**samm-c:StructuredValue**]  | aas:SubmodelElement, aas:ConceptDescription | The general remarks to Characteristics apply also to StructuredValue. However, AAS has no concpet like deconstruction rule. Thus, the deconstruction rule and the sub properties of the deconstruction entity will be ignored and only the Characteristic is mapped.

| xref:samm-specification:ROOT:characteristics.adoc#enumeration-characteristic[**samm-c:Enumeration**]  | aas:SubmodelElement, aas:ConceptDescription | The general remarks to Characteristics apply also to Enumerations. Additionally, the values of an Enumeration are mapped to a valueList of a DataSpecificationIEC61360.

| xref:samm-specification:ROOT:characteristics.adoc#state-characteristic[**samm-c:State**]  | aas:SubmodelElement, aas:ConceptDescription | Same as Enumeration.

| xref:samm-specification:ROOT:characteristics.adoc#MultiLanguageText[samm-c:MultiLanguageText]  | aas:MultiLanguageProperty | if a MultiLanguageText is used in SAMM it is mapped to the MultiLanguageProperty in AAS.
|===

=== Known Limitations
The AAS Generator implements a base set of features, which are mapped from SAMM to AAS.
However, there are still limitations:

* Predefined entity mapping (FileResource would be mapped to aas:File)
* samm-c:Either is mapped to aas:SubmodelElementCollection with two entries for left and right side
* Recursive optional properties of SAMM model are not included in output but dropped straight away

=== Translate Aspect Model to AAS

The following code demonstrates how the API to translate an Aspect Model into one of the valid AAS
formats (JSON, XML, AASX) is used:

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateAas.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateAas.java[tags=generate]
----

To include the translator artifact, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-aas-generator-artifact.adoc[]

[[translate-aas-to-aspect-model]]
=== Translate AAS to Aspect Model

It is also possible to translate AAS Submodel Templates to Aspect Models using a best-effort. The
following example shows how the API to translate an AAS environment containing one or more Submodel
Templates to Aspect Models:

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateAspectFromAas.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateAspectFromAas.java[tags=generate]
----

To include the translator artifact, use the same same dependencies as shown above in section <<translate-aas-to-aspect-model>>.
