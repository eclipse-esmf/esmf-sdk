:page-partial:

[[aspect-model-java-tooling]]
= Getting Started with Java APIs for Aspect Models

[[general-considerations]]
== General Considerations

In this section, the Java APIs for working with Aspect Models are described. All of the components described in the
following subsections can either be included in your project using a dedicated dependency (as described in the
respective subsection), _or_ you can use the `esmf-aspect-model-starter` artifact that aggregates all necessary dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-starter-artifact.adoc[]

Alternatively, you can use the `esmf-sdk-parent` artifact as a
https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Bill_of_Materials_.28BOM.29_POMs[Maven
BOM] (Bill of Materials) to enable declaring dependencies to specific modules without an explicit
version. Add the following section to the Maven pom.xml in your project:

include::esmf-developer-guide:ROOT:partial$esmf-bom.adoc[]

[[versioning]]
== Getting the right version

The tooling can be made available in two different versions: `release` and `milestone`. The release version represents a stable version of the product
and can be referenced in your projects in the usual way from the Maven Central repository. There is also the possibility to have the intermediate builds
made available, these are called `milestone` builds. Instead of Maven Central, these are released via
https://github.com/orgs/eclipse-esmf/packages?repo_name=esmf-sdk[GitHub Packages] mechanism. +
To be able to use the artifacts released in this way in your projects, first the right repository has to be added to your `pom.xml` file:
[source, xml]
----
<repositories>
  <repository>
    <id>github</id>
    <name>ESMF SDK</name>
    <url>https://maven.pkg.github.com/eclipse-esmf/esmf-sdk</url>
    <releases><enabled>true</enabled></releases>
    <snapshots><enabled>true</enabled></snapshots>
  </repository>
</repositories>
----
Then the desired dependencies can be referenced in the usual way. For an example, please refer to
https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-apache-maven-registry#installing-a-package[Github - Installing a package].

[[jdk-requirements]]
== JDK requirements

The esmf-sdk components are built with Java 21 and require a JDK >= 21 such as
https://adoptium.net/[Adoptium Temurin].

The esmf-sdk can also be used with a Java 21-compatible https://www.graalvm.org/[GraalVM JDK].

[TIP]
=====
When using esmf-sdk with a GraalVM JDK and you target `native-image` compilation, add a
dependency to the `esmf-native-support` module. This will add the necessary configuration for
esmf-sdk resources, reflection and initialization that is required by the compiler:

include::esmf-developer-guide:ROOT:partial$esmf-native-support-artifact.adoc[]
=====

[[parsing-aspect-model-urns]]
== Parsing Aspect Model URNs

The `aspect-model-urn` artifact provides a way to parse and validate Aspect model element URNs as described in the
xref:samm-specification:ROOT:namespaces.adoc[specification].

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$ParseAspectModelUrn.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$ParseAspectModelUrn.java[tags=parseAspectModelUrn]
----

To include the artifact, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-urn-artifact.adoc[]

[[loading-and-saving]]
== Loading and Saving Aspect Models

Aspect models are, like the Semantic Aspect Meta Model, described using the Resource Description Format (RDF,
xref:samm-specification:appendix:bibliography.adoc#rdf11[[rdf11\]]) and the Terse RDF Triple Language syntax
(TTL, xref:samm-specification:appendix:bibliography.adoc#turtle[[turtle\]]). When an Aspect Model is loaded,
there are two ways of working with it: Either on the abstraction level of the underlying RDF/Turtle
serialization, or on the native Java Aspect Model level, where the model is represented as a Java object
graph. Both approaches have different use cases and advantages and both are supported by the Aspect Model Java
tooling:

[width="100%", options="header", cols="50,50"]
|===
| Working on the RDF level | Using the Java Aspect model
a|
* Low level, focus on power and flexibility
* Flexibly navigate and filter the model on the RDF statements level
* Work with models that are valid RDF, but incomplete Aspect Models, e.g. in Aspect model editors
* Use SPARQL xref:samm-specification:appendix:bibliography.adoc#sparql[[sparql\]] to execute complex queries on Aspect Models
a|
* High level, focus on convenience and type-safety
* Use Aspect Model-specific interfaces for type-safe code
* Use Java native data types (e.g. `java.math.BigInteger` for `xsd:integer`)
* Easily traverse the model on the abstraction level of Aspect Model elements
|===

As a rule of thumb, if your use case mostly consists of _consuming_ Aspect models, you should prefer the Java
Aspect model, if you _create_ or _edit_ Aspect models, or build code interfacing with other RDF vocabularies,
this is better done using the RDF API.

[[loading-an-aspect-model-java-model-level]]
=== Loading an Aspect Model to work on the Java Aspect Model Level

To load an AspectModel, you use the `org.eclipse.esmf.aspectmodel.loader.AspectModelLoader` class. An instance
of `AspectModelLoader` provides `load()` methods to load an Aspect Model from an InputStream, one or multiple
Files, or a number of `AspectModelUrn` (where you can delegate finding out _where_ a model element is defined
to the AspectModelLoader - details on that are explained in the next section).

The `AspectModelLoader` loads Aspect Models based on the most recent version of the Semantic Aspect Meta Model
and previous versions: Models based on older meta model versions are automatically translated to models
corresponding to the latest meta model version.

The resulting `AspectModel` object contains information about the loaded model elements, their
namespaces and the files they were defined in. Details about the structure of these objects can be
found in the
https://github.com/eclipse-esmf/esmf-semantic-aspect-meta-model/blob/main/documentation/decisions/0007-model-resolution.md[Decision
Record 0007]. The `AspectModel` provides the methods `elements()`, `files()` and `namespaces()` as
well as the convenience methods `aspects()` (which returns all Aspect elements in the model) and
`aspect()`, which returns the single Aspect element if one exists.

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelObjects.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelObjects.java[tags=loadModel]
----

To include the Java Aspect Model artifact, use the following dependency:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-meta-model-java-artifact.adoc[]

[[understanding-model-resolution]]
=== Understanding Model Resolution

The example in the last section showed how a self-contained Aspect Model file can be loaded (i.e., a
file that does not refer to model element definitions in other files or namespaces). Whenever models
are loaded that could contain such references, or you want to load a model element by URN, the
AspectModelLoader relies on so-called _resolution strategies_. A resolution strategy is a function
that takes a model element identifier (a model element URN) as an input and returns the content of
the file that contains the corresponding model element definition. Note that this is not necessarily
a file in the local filesystem, but it could also be a remote file or even exist only virtually as a
collection of statements in an RDF triple store. Several `ResolutionStrategy`&#8203;s are provided
that can be instantiated and passed to the `AspectModelLoader` constructor to enable it to find
model element definitions:

* The `FileSystemStrategy` resolves elements from files in the file system which are either structured in the
  xref:tooling-guide:samm-cli.adoc#models-directory-structure[models directory structure] or exist as flat
  list of files in one directory (by using `FileSystemStrategy` with a `FlatModelsRoot`).
* The `ClassPathStrategy` resolves model elements from resources in the Java class path.
* The `FromLoadedFileStrategy` resolves model elements from an `AspectModelFile` that already resides in
  memory.
* The `EitherStrategy` can be used to chain two or more different `ResolutionStrategy`&#8203;s.
* The `ExternalResolverStrategy` delegates resolution to an external command such as a script; it is used in
  the implementation of the `--custom-resolver` option of the xref:tooling-guide:samm-cli.adoc[samm-cli].
* The `GitHubStrategy` resolves model elements from repositories hosted on GitHub.

In addition, custom resolution strategies can be provided by implementing the `ResolutionStrategy` interface.

The following example demonstrates how to pass a custom instance of a `ResolutionStrategy` and resolve a model
element by URN:

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=loadAndResolveFromUrn]
----

[[loading-an-aspect-model-rdf-level]]
=== Loading an Aspect Model to work on the RDF Level

The following example shows how to use the `AspectModelLoad` to load an Aspect Model.

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=loadAndResolveFromFile]
----

After loading an `AspectModel` using the `AspectModelLoader`, you can access the `mergedModel()` on the
`AspectModel`, which represents the merged RDF graph of all source files that were loaded in the model and
therefore contains all transitively referenced model element definitions. Alternatively, you can also access
the `sourceModel()` of each Aspect Model file given by `files()`, which will return only the RDF graph of this
file.

[[accessing-samm-programmatically]]
== Accessing the SAMM programmatically

In order to access the source RDF files that describe the SAMM vocabulary, shared Characteristics and Entities
as well as Units, you can add a dependency to the `esmf-aspect-meta-model` artifact. Note that this artifact
does not provide Java classes that represent the meta model.

include::esmf-developer-guide:ROOT:partial$aspect-meta-model-artifact.adoc[]

In order to access the files via `java.lang.Class#getResourceAsStream`, you can refer to the following directory
structure that is present in the artifact:

[source,subs="attributes+,+quotes"]
----
.
├── characteristic
│   └── {aspect-meta-model-version}
│       ├── characteristic-definitions.ttl
│       ├── characteristic-instances.ttl
│       ├── characteristic-shapes.ttl
│       └── characteristic-validations.js
├── entity
│   └── {aspect-meta-model-version}
│       ├── FileResource.ttl
│       ├── ThreeDimensionalPosition.ttl
│       └── TimeSeriesEntity.ttl
├── meta-model
│   └── {aspect-meta-model-version}
│       ├── aspect-meta-model-definitions.ttl
│       ├── aspect-meta-model-shapes.ttl
│       ├── prefix-declarations.ttl
│       └── type-conversions.ttl
└── unit
    └── {aspect-meta-model-version}
        └── units.ttl
----

TIP: You can use the `MetaModelFile` enumeration provided by the `esmf-aspect-meta-model-java` module to
access object representations of the meta model files, for example:

++++
<details>
<summary>Show used imports</summary>
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadMetaModelRdf.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadMetaModelRdf.java[tags=loadMetaModelRdf]
----

== Next Steps

For more advanced topics, see the dedicated pages:

* xref:java-model-creation.adoc[Creating and Modifying Models] - Learn how to programmatically create and modify Aspect Models
* xref:java-validation.adoc[Validation] - Validate your Aspect Models and handle validation results
* xref:java-code-generation.adoc[Code Generation] - Generate Java POJOs, static classes, and SQL from your models
* xref:java-documentation-generation.adoc[Documentation Generation] - Create diagrams, HTML docs, JSON schemas, and API specifications
* xref:java-aas-mapping.adoc[AAS Integration] - Map between SAMM Aspect Models and Asset Administration Shell submodels
